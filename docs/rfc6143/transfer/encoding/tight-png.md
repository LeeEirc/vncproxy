# 严格Png编码 Tight Encoding

严格编码为像素数据提供了有效的压缩。为了减少执行的复杂性，任何Tight编码的矩形的宽度不能超过2048像素。
如果需要一个更宽的矩形，必须将其分成几个矩形，每个矩形都要单独编码。

每个Tight-encoded矩形的第一个字节是一个压缩控制字节。

```
+--------------+--------------+----------------+
| No. of bytes | Type [Value] | Description    |
+--------------+--------------+----------------+
| 1            | U8          | 压缩控制字节      |
+--------------+--------------+----------------+
```

压缩控制字节中最低有效位四位标识了客户端在解码矩形之前应该重置哪些zlib压缩流。
每个位都是独立的，对应于一个应该被重置的单独的zlib流。

```
+-----+----------------+
| Bit | Description    | 
+-----+----------------+
| 0   | Reset stream 0 | 
| 1   | Reset stream 1 | 
| 2   | Reset stream 2 | 
| 3   | Reset stream 3 | 
+-----+----------------+
```

在Tight编码中，支持三种可能的压缩方法之一。它们是`BasicCompression`, `FillCompression`和`JpegCompression`。

如果`压缩控制字节`的第7位（最高位）是0，那么压缩类型是BasicCompression。
在这种情况下，压缩控制的第7-4位（最重要的4位）应该被解释为如下：

```
+--------------+--------------+----------------+
| Bits         | Binary value | Description    |
+--------------+--------------+----------------+
| 5-4          | 00          | Use stream 0    |
|              | 01          | Use stream 1    |
|              | 10          | Use stream 2    |
|              | 11          | Use stream 3    |
| 6            | 0           | ---             |
|              | 1           | read-filter-id  |
| 7            | 0           | BasicCompression|
+--------------+--------------+----------------+
```

否则，如果`压缩控制字节`的第7位设置为1，则压缩方法是`FillCompression`或`JpegCompression`，取决于同一字节的其他位：

```
+--------------+--------------+----------------+
| Bits         | Binary value | Description    |
+--------------+--------------+----------------+
| 7-4          | 1000         | FillCompression|
|              | 1001         | JpegCompression|
|              | any other    | Invalid        |
+--------------+--------------+----------------+
```

> 注意：`JpegCompression` 只能在像素编码为 16 或 32 并且客户端已使用 ` JPEG Quality Level Pseudo-encoding`。

Tight 编码使用一种新型 `TPIXEL`（Tight 像素）。
这与商定的像素格式的 PIXEL 相同，除了真彩色标志非零、每像素位数为 32、深度为 24 以及构成红色、绿色和蓝色强度的所有位正好是 8 位宽。
在这种情况下，`TPIXEL` 只有 3 个字节长，其中第一个字节是红色分量，第二个字节是绿色分量，第三个字节是像素颜色值的蓝色分量。

> 压缩控制字节之后的数据取决于压缩方法。

- FillCompression

    如果压缩类型为 `FillCompression`，则后面是唯一的像素值，采用 `TPIXEL` 格式。此值适用于矩形的所有像素。
- JpegCompression

  如果压缩类型为 `JpegCompression`，则以下数据流如下所示：

    ```
    +--------------+--------------+----------------+
    | No. of bytes | Type      | Description       |
    +--------------+-----------+-------------------+
    | 1-3          |           | jpeg数据的长度     |
    | length       | U8 array  | jpeg-data         |
    +--------------+-----------+-------------------+
    ```
  根据以下方案，长度动态压缩表示为一个、两个或三个字节：

  ```
  +----------------------------+---------------------------+
  | Value                      | Description               |
  +----------------------------+---------------------------+
  | 0xxxxxxx	               | for values 0..127         |
  | 1xxxxxxx 0yyyyyyy          | for values 128..16383     |
  | 1xxxxxxx 1yyyyyyy zzzzzzzz | for values 16384..4194303 |
  +----------------------------+---------------------------+
  ```
  这里每个字符表示一位，`xxxxxxx` 是值的最低 7 位（位 0-6），`yyyyyyy` 是 7-13 位，`zzzzzzzz` 是最高有效 8 位（14-21 位）。例如，十进制值 10000 应表示为两个字节：二进制 10010000 01001110，或十六进制 90 4E。
  > jpeg-data 是 JFIF 流

- BasicCompression

  如果压缩类型是 `BasicCompression` 并且压缩控制字节的第 6 位（read-filter-id 位）设置为 1，
  则下一个（第二个）字节指定 `filter-id`，它告诉解码器使用什么过滤器类型编码器在压缩之前对像素数据进行预处理。 
  `filter-id` 字节可以是以下之一：

  ```
    +--------------+-------+-----------+-------------------------+
    | No. of bytes | Type  | [Value]   | Description             |
    +--------------+-------+-----------+-------------------------+
    | 1            |  U8   |           | filter-id               |
    |              |       | 0         | CopyFilter (no filter)  |
    |              |       | 1         | PaletteFilter           |
    |              |       | 2         | GradientFilter          |
    +--------------+-------+-----------+-------------------------+
  ```
  如果压缩控制字节的第 6 位设置为 0（无过滤器 ID 字节），则使用 `CopyFilter`。
  
  - `CopyFilter`

     当 `CopyFilter` 处于活动状态时，将压缩 `TPIXEL` 格式的原始像素值。有关压缩的详细信息，请参见下文。
  - `PaletteFilter`
   
     `PaletteFilter` 将真彩色像素数据转换为索引颜色和可由 2..256 种颜色组成的调色板。
     如果颜色数为 2，则每个像素用 1 位编码，否则 8 位用于编码一个像素。
     1位编码的执行方式是最高有效位对应于最左边的像素，并且每行像素都与字节边界对齐。
     使用 `PaletteFilter` 时，调色板在像素数据之前发送。调色板以一个无符号字节开始，其值是调色板中的颜色数减 1（即 1 表示 2 种颜色，255 表示调色板中的 256 种颜色）。
     然后是调色板本身，它由 `TPIXEL` 格式的像素值组成。
  
  - `GradientFilter`
    
    GradientFilter 使用一种简单的算法对像素数据进行预处理，该算法将每个颜色分量转换为“预测”强度和实际强度之间的差异。这种技术不会影响未压缩的数据大小，但有助于更好地压缩类似照片的图像。将强度转换为差异的伪代码如下： 
    ```
    P[i,j] := V[i-1,j] + V[i,j-1] - V[i-1,j-1];
    if (P[i,j] < 0) then P[i,j] := 0;
    if (P[i,j] > MAX) then P[i,j] := MAX;
    D[i,j] := V[i,j] - P[i,j];
    ```
    这里 `V[i,j]` 是坐标 `(i,j)` 处像素的颜色分量的强度。对于当前矩形之外的像素，假设 `V[i,j]` 为零（这与 `P[i,0]` 和 `P[0,j]` 相关）。 
    MAX 是颜色分量的最大强度值。
    > 注意：`GradientFilter` 只能在 bits-per-pixel 为 16 或 32 时使用。

  使用上述三个过滤器之一过滤像素数据后，使用 `zlib` 库对其进行压缩。
  但是，如果在应用过滤器之后但在压缩之前的数据大小小于 12，则数据按原样发送，未压缩。
  可以使用四个单独的 zlib 流（0..3），解码器应该从压缩控制字节中读取实际的流 id。

  如果不使用压缩，则按原样发送像素数据，否则数据流如下所示：

  ```
    +--------------+--------------+----------------+
    | No. of bytes | Type      | Description       |
    +--------------+-----------+-------------------+
    | 1-3          |           | zlib数据的长度     |
    | length       | U8 array  | zlibData         |
    +--------------+-----------+-------------------+
    ```
  长度紧凑地表示为一个、两个或三个字节，就像在 JpegCompression 方法中一样（见上文）。

如果压缩控制字节中的某些位 0、1、2 和 3 设置为 1，则解码器必须在解码矩形之前重置 `zlib` 流。请注意，即使压缩类型为解码器，解码器也必须重置指示的 zlib 流是 `FillCompression` 或 `JpegCompression`。






